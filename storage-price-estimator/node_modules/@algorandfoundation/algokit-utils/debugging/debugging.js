'use strict';

var crypto = require('crypto');
var app = require('../app.js');
var config = require('../config.js');
var types_debugging = require('../types/debugging.js');
var util = require('../util.js');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var crypto__namespace = /*#__PURE__*/_interopNamespaceDefault(crypto);

const ALGOKIT_DIR = '.algokit';
const SOURCES_DIR = 'sources';
const SOURCES_FILE = 'sources.avm.json';
const TEAL_FILE_EXT = '.teal';
const TEAL_SOURCEMAP_EXT = '.teal.tok.map';
// === Internal methods ===
async function loadOrCreateSources(sourcesPath) {
    try {
        const fs = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespaceDefault(require('fs')); });
        const data = JSON.parse(await fs.promises.readFile(sourcesPath, 'utf8'));
        return types_debugging.AVMDebuggerSourceMap.fromDict(data);
    }
    catch (error) {
        const err = error;
        if (err.code === 'ENOENT') {
            return new types_debugging.AVMDebuggerSourceMap([]);
        }
        else {
            throw error;
        }
    }
}
async function upsertDebugSourcemaps(sourceMaps, projectRoot) {
    const path = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespaceDefault(require('path')); });
    const fs = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespaceDefault(require('fs')); });
    const sourcesPath = path.join(projectRoot, ALGOKIT_DIR, SOURCES_DIR, SOURCES_FILE);
    const sources = await loadOrCreateSources(sourcesPath);
    for (const sourcemap of sourceMaps) {
        const sourceFilePath = path.resolve(sourcemap.location);
        try {
            await fs.promises.access(sourceFilePath);
            const index = sources.txnGroupSources.findIndex((item) => item.equals(sourcemap));
            if (index === -1) {
                sources.txnGroupSources.push(sourcemap);
            }
            else {
                sources.txnGroupSources[index] = sourcemap;
            }
        }
        catch (error) {
            const err = error;
            if (err.code === 'ENOENT') {
                const index = sources.txnGroupSources.findIndex((item) => item.equals(sourcemap));
                if (index !== -1) {
                    sources.txnGroupSources.splice(index, 1);
                }
            }
            else {
                throw error;
            }
        }
    }
    await fs.promises.writeFile(sourcesPath, JSON.stringify(sources.toDict()), 'utf8');
}
async function writeToFile(filePath, content) {
    const path = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespaceDefault(require('path')); });
    const fs = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespaceDefault(require('fs')); });
    await fs.promises.mkdir(path.dirname(filePath), { recursive: true });
    await fs.promises.writeFile(filePath, content, 'utf8');
}
async function buildAVMSourcemap({ rawTeal, compiledTeal, appName, fileName, outputPath, client, withSources = true, }) {
    if (!rawTeal && !compiledTeal) {
        throw new Error('Either rawTeal or compiledTeal must be provided.');
    }
    const path = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespaceDefault(require('path')); });
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const result = rawTeal ? await app.compileTeal(rawTeal, client) : compiledTeal;
    const programHash = crypto__namespace.createHash('SHA-512/256').update(Buffer.from(result.compiled, 'base64')).digest('base64');
    const sourceMap = result.sourceMap;
    sourceMap.sources = withSources ? [`${fileName}${TEAL_FILE_EXT}`] : [];
    const outputDirPath = path.join(outputPath, ALGOKIT_DIR, SOURCES_DIR, appName);
    const sourceMapOutputPath = path.join(outputDirPath, `${fileName}${TEAL_SOURCEMAP_EXT}`);
    const tealOutputPath = path.join(outputDirPath, `${fileName}${TEAL_FILE_EXT}`);
    await writeToFile(sourceMapOutputPath, JSON.stringify(sourceMap));
    if (withSources && result) {
        await writeToFile(tealOutputPath, result.teal);
    }
    return new types_debugging.AVMDebuggerSourceMapEntry(sourceMapOutputPath, programHash);
}
// === Public facing methods ===
/**
 * This function persists the source maps for the given sources.
 *
 * @param param0 The parameters to define the persistence
 *
 * @returns A promise that resolves when the source maps have been persisted.
 */
async function persistSourceMaps({ sources, projectRoot, client, withSources }) {
    if (!util.isNode()) {
        throw new Error('Sourcemaps can only be persisted in Node.js environment.');
    }
    try {
        const sourceMaps = await Promise.all(sources.map((source) => buildAVMSourcemap({
            rawTeal: source.rawTeal,
            compiledTeal: source.compiledTeal,
            appName: source.appName,
            fileName: source.fileName,
            outputPath: projectRoot,
            client: client,
            withSources: withSources,
        })));
        await upsertDebugSourcemaps(sourceMaps, projectRoot);
    }
    catch (error) {
        const err = error instanceof Error ? error : new Error(String(error));
        config.Config.getLogger().error(`Failed to persist avm sourceMaps: ${err.stack ?? err.message ?? err}.`);
        throw err;
    }
}

exports.persistSourceMaps = persistSourceMaps;
//# sourceMappingURL=debugging.js.map
