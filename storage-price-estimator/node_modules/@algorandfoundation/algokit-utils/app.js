'use strict';

var algosdk = require('algosdk');
var buffer = require('buffer');
var config = require('./config.js');
var transaction = require('./transaction/transaction.js');
var types_app = require('./types/app.js');
var util = require('./util.js');

var ABIMethod = algosdk.ABIMethod;
var AtomicTransactionComposer = algosdk.AtomicTransactionComposer;
var modelsv2 = algosdk.modelsv2;
var OnApplicationComplete = algosdk.OnApplicationComplete;
var SourceMap = algosdk.SourceMap;
/**
 * Creates a smart contract app, returns the details of the created app.
 * @param create The parameters to create the app with
 * @param algod An algod client
 * @returns The details of the created app, or the transaction to create it if `skipSending` and the compilation result
 */
async function createApp(create, algod) {
    const { from, approvalProgram: approval, clearStateProgram: clear, schema, note, transactionParams, args, onCompleteAction, ...sendParams } = create;
    const compiledApproval = typeof approval === 'string' ? await compileTeal(approval, algod) : undefined;
    const approvalProgram = compiledApproval ? compiledApproval.compiledBase64ToBytes : approval;
    const compiledClear = typeof clear === 'string' ? await compileTeal(clear, algod) : undefined;
    const clearProgram = compiledClear ? compiledClear.compiledBase64ToBytes : clear;
    if (args && args.method) {
        const atc = attachATC(sendParams);
        const before = transaction.getAtomicTransactionComposerTransactions(atc);
        atc.addMethodCall({
            appID: 0,
            approvalProgram: approvalProgram,
            clearProgram: clearProgram,
            numLocalInts: schema.localInts,
            numLocalByteSlices: schema.localByteSlices,
            numGlobalInts: schema.globalInts,
            numGlobalByteSlices: schema.globalByteSlices,
            extraPages: schema.extraPages ?? Math.floor((approvalProgram.length + clearProgram.length) / types_app.APP_PAGE_MAX_SIZE),
            onComplete: getAppOnCompleteAction(onCompleteAction),
            suggestedParams: transaction.controlFees(await transaction.getTransactionParams(transactionParams, algod), sendParams),
            note: transaction.encodeTransactionNote(note),
            ...(await getAppArgsForABICall(args, from)),
        });
        if (sendParams.skipSending) {
            const after = atc.clone().buildGroup();
            return {
                transaction: after[after.length - 1].txn,
                transactions: after.slice(before.length).map((t) => t.txn),
                appId: 0,
                appAddress: '',
                compiledApproval,
                compiledClear,
            };
        }
        const result = await transaction.sendAtomicTransactionComposer({ atc, sendParams }, algod);
        const confirmation = result.confirmations ? result.confirmations[result.confirmations?.length - 1] : undefined;
        if (confirmation) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const appId = confirmation.applicationIndex;
            config.Config.getLogger(sendParams.suppressLog).debug(`Created app ${appId} from creator ${transaction.getSenderAddress(from)}`);
            return {
                transactions: result.transactions,
                confirmations: result.confirmations,
                return: confirmation ? getABIReturn(args, confirmation) : undefined,
                transaction: result.transactions[result.transactions.length - 1],
                confirmation: confirmation,
                appId,
                appAddress: algosdk.getApplicationAddress(appId),
                compiledApproval,
                compiledClear,
            };
        }
        else {
            return {
                transactions: result.transactions,
                confirmations: result.confirmations,
                return: confirmation ? getABIReturn(args, confirmation) : undefined,
                transaction: result.transactions[result.transactions.length - 1],
                confirmation: confirmation,
                appId: 0,
                appAddress: '',
                compiledApproval,
                compiledClear,
            };
        }
    }
    else {
        const transaction$1 = algosdk.makeApplicationCreateTxnFromObject({
            approvalProgram: approvalProgram,
            clearProgram: clearProgram,
            numLocalInts: schema.localInts,
            numLocalByteSlices: schema.localByteSlices,
            numGlobalInts: schema.globalInts,
            numGlobalByteSlices: schema.globalByteSlices,
            extraPages: schema.extraPages ?? Math.floor((approvalProgram.length + clearProgram.length) / types_app.APP_PAGE_MAX_SIZE),
            onComplete: getAppOnCompleteAction(onCompleteAction),
            suggestedParams: await transaction.getTransactionParams(transactionParams, algod),
            from: transaction.getSenderAddress(from),
            note: transaction.encodeTransactionNote(note),
            ...getAppArgsForTransaction(args),
            rekeyTo: args?.rekeyTo ? (typeof args.rekeyTo === 'string' ? args.rekeyTo : transaction.getSenderAddress(args.rekeyTo)) : undefined,
        });
        const { confirmation } = await transaction.sendTransaction({ transaction: transaction$1, from, sendParams }, algod);
        if (confirmation) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const appId = confirmation.applicationIndex;
            config.Config.getLogger(sendParams.suppressLog).debug(`Created app ${appId} from creator ${transaction.getSenderAddress(from)}`);
            return {
                transaction: transaction$1,
                transactions: [transaction$1],
                confirmation,
                confirmations: confirmation ? [confirmation] : undefined,
                appId,
                appAddress: algosdk.getApplicationAddress(appId),
                return: getABIReturn(args, confirmation),
                compiledApproval,
                compiledClear,
            };
        }
        else {
            return { transaction: transaction$1, transactions: [transaction$1], appId: 0, appAddress: '', compiledApproval, compiledClear };
        }
    }
}
/**
 * Updates a smart contract app.
 * @param update The parameters to update the app with
 * @param algod An algod client
 * @returns The transaction send result and the compilation result
 */
async function updateApp(update, algod) {
    const { appId, from, approvalProgram: approval, clearStateProgram: clear, note, transactionParams, args, ...sendParams } = update;
    const compiledApproval = typeof approval === 'string' ? await compileTeal(approval, algod) : undefined;
    const approvalProgram = compiledApproval ? compiledApproval.compiledBase64ToBytes : approval;
    const compiledClear = typeof clear === 'string' ? await compileTeal(clear, algod) : undefined;
    const clearProgram = compiledClear ? compiledClear.compiledBase64ToBytes : clear;
    config.Config.getLogger(sendParams.suppressLog).debug(`Updating app ${appId}`);
    if (args && args.method) {
        const atc = attachATC(sendParams);
        const before = transaction.getAtomicTransactionComposerTransactions(atc);
        atc.addMethodCall({
            appID: util.toNumber(appId),
            onComplete: OnApplicationComplete.UpdateApplicationOC,
            approvalProgram: approvalProgram,
            clearProgram: clearProgram,
            suggestedParams: transaction.controlFees(await transaction.getTransactionParams(transactionParams, algod), sendParams),
            note: transaction.encodeTransactionNote(note),
            ...(await getAppArgsForABICall(args, from)),
        });
        if (sendParams.skipSending) {
            const after = atc.clone().buildGroup();
            return {
                transaction: after[after.length - 1].txn,
                transactions: after.slice(before.length).map((t) => t.txn),
            };
        }
        const result = await transaction.sendAtomicTransactionComposer({ atc, sendParams }, algod);
        const confirmation = result.confirmations ? result.confirmations[result.confirmations?.length - 1] : undefined;
        return {
            transactions: result.transactions,
            confirmations: result.confirmations,
            return: confirmation ? getABIReturn(args, confirmation) : undefined,
            transaction: result.transactions[result.transactions.length - 1],
            confirmation: confirmation,
        };
    }
    else {
        const transaction$1 = algosdk.makeApplicationUpdateTxnFromObject({
            appIndex: util.toNumber(appId),
            approvalProgram: approvalProgram,
            clearProgram: clearProgram,
            suggestedParams: await transaction.getTransactionParams(transactionParams, algod),
            from: transaction.getSenderAddress(from),
            note: transaction.encodeTransactionNote(note),
            ...getAppArgsForTransaction(args),
            rekeyTo: args?.rekeyTo ? (typeof args.rekeyTo === 'string' ? args.rekeyTo : transaction.getSenderAddress(args.rekeyTo)) : undefined,
        });
        const result = await transaction.sendTransaction({ transaction: transaction$1, from, sendParams }, algod);
        return {
            ...result,
            transactions: [result.transaction],
            confirmations: result.confirmation ? [result.confirmation] : undefined,
            return: getABIReturn(args, result.confirmation),
            compiledApproval,
            compiledClear,
        };
    }
}
function attachATC(sendParams) {
    if (sendParams.atc) {
        sendParams.skipSending = true;
    }
    sendParams.atc = sendParams.atc ?? new AtomicTransactionComposer();
    return sendParams.atc;
}
/** Returns an `algosdk.OnApplicationComplete` for the given onCompleteAction.
 *
 * If given `undefined` will return `OnApplicationComplete.NoOpOC`.
 *
 * If given an `AppCallType` will convert the string enum to the correct underlying `algosdk.OnApplicationComplete`.
 *
 * @param onCompletionAction The on completion action
 * @returns The `algosdk.OnApplicationComplete`
 */
function getAppOnCompleteAction(onCompletionAction) {
    switch (onCompletionAction) {
        case undefined:
        case 'no_op':
        case OnApplicationComplete.NoOpOC:
            return OnApplicationComplete.NoOpOC;
        case 'opt_in':
        case OnApplicationComplete.OptInOC:
            return OnApplicationComplete.OptInOC;
        case 'close_out':
        case OnApplicationComplete.CloseOutOC:
            return OnApplicationComplete.CloseOutOC;
        case 'clear_state':
        case OnApplicationComplete.ClearStateOC:
            return OnApplicationComplete.ClearStateOC;
        case 'update_application':
        case OnApplicationComplete.UpdateApplicationOC:
            return OnApplicationComplete.UpdateApplicationOC;
        case 'delete_application':
        case OnApplicationComplete.DeleteApplicationOC:
            return OnApplicationComplete.DeleteApplicationOC;
    }
}
/**
 * Issues a call to a given app.
 * @param call The call details.
 * @param algod An algod client
 * @returns The result of the call
 */
async function callApp(call, algod) {
    const { appId, callType, from, args, note, transactionParams, ...sendParams } = call;
    if (args && args.method) {
        const atc = attachATC(sendParams);
        const before = transaction.getAtomicTransactionComposerTransactions(atc);
        atc.addMethodCall({
            appID: util.toNumber(appId),
            suggestedParams: transaction.controlFees(await transaction.getTransactionParams(transactionParams, algod), sendParams),
            note: transaction.encodeTransactionNote(note),
            onComplete: getAppOnCompleteAction(callType),
            ...(await getAppArgsForABICall(args, from)),
        });
        if (sendParams.skipSending) {
            const after = atc.clone().buildGroup();
            return {
                transaction: after[after.length - 1].txn,
                transactions: after.slice(before.length).map((t) => t.txn),
            };
        }
        const result = await transaction.sendAtomicTransactionComposer({ atc, sendParams }, algod);
        const confirmation = result.confirmations ? result.confirmations[result.confirmations?.length - 1] : undefined;
        return {
            transactions: result.transactions,
            confirmations: result.confirmations,
            return: confirmation ? getABIReturn(args, confirmation) : undefined,
            transaction: result.transactions[result.transactions.length - 1],
            confirmation: confirmation,
        };
    }
    const appCallParams = {
        appIndex: util.toNumber(appId),
        from: transaction.getSenderAddress(from),
        suggestedParams: await transaction.getTransactionParams(transactionParams, algod),
        ...getAppArgsForTransaction(args),
        note: transaction.encodeTransactionNote(note),
        rekeyTo: args?.rekeyTo ? (typeof args.rekeyTo === 'string' ? args.rekeyTo : transaction.getSenderAddress(args.rekeyTo)) : undefined,
    };
    let transaction$1;
    switch (getAppOnCompleteAction(callType)) {
        case OnApplicationComplete.OptInOC:
            transaction$1 = algosdk.makeApplicationOptInTxnFromObject(appCallParams);
            break;
        case OnApplicationComplete.ClearStateOC:
            transaction$1 = algosdk.makeApplicationClearStateTxnFromObject(appCallParams);
            break;
        case OnApplicationComplete.CloseOutOC:
            transaction$1 = algosdk.makeApplicationCloseOutTxnFromObject(appCallParams);
            break;
        case OnApplicationComplete.DeleteApplicationOC:
            transaction$1 = algosdk.makeApplicationDeleteTxnFromObject(appCallParams);
            break;
        case OnApplicationComplete.NoOpOC:
            transaction$1 = algosdk.makeApplicationNoOpTxnFromObject(appCallParams);
            break;
        default:
            throw new Error(`Received unexpected call type ${callType}`);
    }
    const result = await transaction.sendTransaction({ transaction: transaction$1, from, sendParams }, algod);
    return {
        ...result,
        transactions: [result.transaction],
        confirmations: result.confirmation ? [result.confirmation] : undefined,
        return: getABIReturn(args, result.confirmation),
    };
}
/**
 * Returns any ABI return values for the given app call arguments and transaction confirmation.
 * @param args The arguments that were used for the call
 * @param confirmation The transaction confirmation from algod
 * @returns The return value for the method call
 */
function getABIReturn(args, confirmation) {
    if (!args || !args.method) {
        return undefined;
    }
    const method = 'txnCount' in args.method ? args.method : new ABIMethod(args.method);
    if (method.returns.type !== 'void' && confirmation) {
        // The parseMethodResponse method mutates the second parameter :(
        const resultDummy = {
            txID: '',
            method,
            rawReturnValue: new Uint8Array(),
        };
        const response = AtomicTransactionComposer.parseMethodResponse(method, resultDummy, confirmation);
        return !response.decodeError
            ? {
                rawReturnValue: response.rawReturnValue,
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                returnValue: response.returnValue,
                decodeError: undefined,
            }
            : {
                rawReturnValue: undefined,
                returnValue: undefined,
                decodeError: response.decodeError,
            };
    }
    return undefined;
}
/**
 * Returns the current global state values for the given app ID
 * @param appId The ID of the app return global state for
 * @param algod An algod client instance
 * @returns The current global state
 */
async function getAppGlobalState(appId, algod) {
    const appInfo = await getAppById(appId, algod);
    if (!appInfo.params || !appInfo.params.globalState) {
        throw new Error("Couldn't find global state");
    }
    return decodeAppState(appInfo.params.globalState);
}
/**
 * Returns the current global state values for the given app ID and account
 * @param appId The ID of the app return global state for
 * @param account Either the string address of an account or an account object for the account to get local state for the given app
 * @param algod An algod client instance
 * @returns The current local state for the given (app, account) combination
 */
async function getAppLocalState(appId, account, algod) {
    const accountAddress = typeof account === 'string' ? account : transaction.getSenderAddress(account);
    const appInfo = modelsv2.AccountApplicationResponse.from_obj_for_encoding(await algod.accountApplicationInformation(accountAddress, util.toNumber(appId)).do());
    if (!appInfo.appLocalState?.keyValue) {
        throw new Error("Couldn't find local state");
    }
    return decodeAppState(appInfo.appLocalState.keyValue);
}
/**
 * Returns the names of the boxes for the given app.
 * @param appId The ID of the app return box names for
 * @param algod An algod client instance
 * @returns The current box names
 */
async function getAppBoxNames(appId, algod) {
    const boxResult = await algod.getApplicationBoxes(util.toNumber(appId)).do();
    return boxResult.boxes.map((b) => {
        return {
            nameRaw: b.name,
            nameBase64: buffer.Buffer.from(b.name).toString('base64'),
            name: buffer.Buffer.from(b.name).toString('utf-8'),
        };
    });
}
/**
 * Returns the value of the given box name for the given app.
 * @param appId The ID of the app return box names for
 * @param boxName The name of the box to return either as a string, binary array or `BoxName`
 * @param algod An algod client instance
 * @returns The current box value as a byte array
 */
async function getAppBoxValue(appId, boxName, algod) {
    const name = typeof boxName === 'string' ? new Uint8Array(buffer.Buffer.from(boxName, 'utf-8')) : 'name' in boxName ? boxName.nameRaw : boxName;
    const boxResult = await algod.getApplicationBoxByName(util.toNumber(appId), name).do();
    return boxResult.value;
}
/**
 * Returns the value of the given box names for the given app.
 * @param appId The ID of the app return box names for
 * @param boxNames The names of the boxes to return either as a string, binary array or `BoxName`
 * @param algod An algod client instance
 * @returns The current box values as a byte array in the same order as the passed in box names
 */
async function getAppBoxValues(appId, boxNames, algod) {
    return await Promise.all(boxNames.map(async (boxName) => await getAppBoxValue(appId, boxName, algod)));
}
/**
 * Returns the value of the given box name for the given app decoded based on the given ABI type.
 * @param request The parameters for the box value request
 * @param algod An algod client instance
 * @returns The current box value as an ABI value
 */
async function getAppBoxValueFromABIType(request, algod) {
    const { appId, boxName, type } = request;
    const value = await getAppBoxValue(appId, boxName, algod);
    return type.decode(value);
}
/**
 * Returns the value of the given box names for the given app decoded based on the given ABI type.
 * @param request The parameters for the box value request
 * @param algod An algod client instance
 * @returns The current box values as an ABI value in the same order as the passed in box names
 */
async function getAppBoxValuesFromABIType(request, algod) {
    const { appId, boxNames, type } = request;
    return await Promise.all(boxNames.map(async (boxName) => await getAppBoxValueFromABIType({ appId, boxName, type }, algod)));
}
/**
 * Converts an array of global/local state values from the algod api to a more friendly
 * generic object keyed by the UTF-8 value of the key.
 * @param state A `global-state`, `local-state`, `global-state-deltas` or `local-state-deltas`
 * @returns An object keyeed by the UTF-8 representation of the key with various parsings of the values
 */
function decodeAppState(state) {
    const stateValues = {};
    // Start with empty set
    for (const stateVal of state) {
        const keyBase64 = stateVal.key;
        const keyRaw = buffer.Buffer.from(keyBase64, 'base64');
        const key = keyRaw.toString('utf-8');
        const tealValue = stateVal.value;
        const dataTypeFlag = 'action' in tealValue ? tealValue.action : tealValue.type;
        let valueBase64;
        let valueRaw;
        switch (dataTypeFlag) {
            case 1:
                valueBase64 = tealValue.bytes ?? '';
                valueRaw = buffer.Buffer.from(valueBase64, 'base64');
                stateValues[key] = {
                    keyRaw,
                    keyBase64,
                    valueRaw: new Uint8Array(valueRaw),
                    valueBase64: valueBase64,
                    value: valueRaw.toString('utf-8'),
                };
                break;
            case 2: {
                const value = tealValue.uint ?? 0;
                stateValues[key] = {
                    keyRaw,
                    keyBase64,
                    value,
                };
                break;
            }
            default:
                throw new Error(`Received unknown state data type of ${dataTypeFlag}`);
        }
    }
    return stateValues;
}
/**
 * Returns the app args ready to load onto an app `Transaction` object
 * @param args The app call args
 * @returns The args ready to load into a `Transaction`
 */
function getAppArgsForTransaction(args) {
    if (!args)
        return undefined;
    const encoder = new TextEncoder();
    return {
        accounts: args?.accounts?.map(_getAccountAddress),
        appArgs: args?.appArgs?.map((a) => (typeof a === 'string' ? encoder.encode(a) : a)),
        boxes: args.boxes?.map(getBoxReference),
        foreignApps: args?.apps,
        foreignAssets: args?.assets,
        lease: transaction.encodeLease(args?.lease),
    };
}
/**
 * Returns the app args ready to load onto an ABI method call in `AtomicTransactionComposer`
 * @param args The ABI app call args
 * @param from The transaction signer
 * @returns The parameters ready to pass into `addMethodCall` within AtomicTransactionComposer
 */
async function getAppArgsForABICall(args, from) {
    const signer = transaction.getSenderTransactionSigner(from);
    const methodArgs = await Promise.all(('methodArgs' in args ? args.methodArgs : args)?.map(async (a, index) => {
        if (a === undefined) {
            throw new Error(`Argument at position ${index} does not have a value`);
        }
        if (typeof a !== 'object') {
            return a;
        }
        // Handle the various forms of transactions to wrangle them for ATC
        return 'txn' in a
            ? a
            : a instanceof Promise
                ? { txn: (await a).transaction, signer }
                : 'transaction' in a
                    ? { txn: a.transaction, signer: 'signer' in a ? transaction.getSenderTransactionSigner(a.signer) : signer }
                    : 'txID' in a
                        ? { txn: a, signer }
                        : a;
    }));
    return {
        method: 'txnCount' in args.method ? args.method : new ABIMethod(args.method),
        sender: transaction.getSenderAddress(from),
        signer: signer,
        boxes: args.boxes?.map(getBoxReference),
        lease: transaction.encodeLease(args.lease),
        appForeignApps: args.apps,
        appForeignAssets: args.assets,
        appAccounts: args.accounts?.map(_getAccountAddress),
        methodArgs: methodArgs,
        rekeyTo: args?.rekeyTo ? (typeof args.rekeyTo === 'string' ? args.rekeyTo : transaction.getSenderAddress(args.rekeyTo)) : undefined,
    };
}
/**
 * Returns a `algosdk.BoxReference` given a `BoxIdentifier` or `BoxReference`.
 * @param box The box to return a reference for
 * @returns The box reference ready to pass into a `Transaction`
 */
function getBoxReference(box) {
    const encoder = new TextEncoder();
    if (typeof box === 'object' && 'appIndex' in box) {
        return box;
    }
    const ref = typeof box === 'object' && 'appId' in box ? box : { appId: 0, name: box };
    return {
        appIndex: ref.appId,
        name: typeof ref.name === 'string'
            ? encoder.encode(ref.name)
            : 'length' in ref.name
                ? ref.name
                : algosdk.decodeAddress(transaction.getSenderAddress(ref.name)).publicKey,
    };
}
function _getAccountAddress(account) {
    return typeof account === 'string' ? account : algosdk.encodeAddress(account.publicKey);
}
/**
 * Gets the current data for the given app from algod.
 *
 * @param appId The id of the app
 * @param algod An algod client
 * @returns The data about the app
 */
async function getAppById(appId, algod) {
    return modelsv2.Application.from_obj_for_encoding(await algod.getApplicationByID(util.toNumber(appId)).do());
}
/**
 * Compiles the given TEAL using algod and returns the result, including source map.
 *
 * @param algod An algod client
 * @param tealCode The TEAL code
 * @returns The information about the compiled file
 */
async function compileTeal(tealCode, algod) {
    const compiled = await algod.compile(tealCode).sourcemap(true).do();
    return {
        teal: tealCode,
        compiled: compiled.result,
        compiledHash: compiled.hash,
        compiledBase64ToBytes: new Uint8Array(buffer.Buffer.from(compiled.result, 'base64')),
        sourceMap: new SourceMap(compiled['sourcemap']),
    };
}
/**
 * Returns the encoded ABI spec for a given ABI Method
 * @param method The method to return a signature for
 * @returns The encoded ABI method spec e.g. `method_name(uint64,string)string`
 */
const getABIMethodSignature = (method) => {
    return 'getSignature' in method ? method.getSignature() : new ABIMethod(method).getSignature();
};

exports.callApp = callApp;
exports.compileTeal = compileTeal;
exports.createApp = createApp;
exports.decodeAppState = decodeAppState;
exports.getABIMethodSignature = getABIMethodSignature;
exports.getABIReturn = getABIReturn;
exports.getAppArgsForABICall = getAppArgsForABICall;
exports.getAppArgsForTransaction = getAppArgsForTransaction;
exports.getAppBoxNames = getAppBoxNames;
exports.getAppBoxValue = getAppBoxValue;
exports.getAppBoxValueFromABIType = getAppBoxValueFromABIType;
exports.getAppBoxValues = getAppBoxValues;
exports.getAppBoxValuesFromABIType = getAppBoxValuesFromABIType;
exports.getAppById = getAppById;
exports.getAppGlobalState = getAppGlobalState;
exports.getAppLocalState = getAppLocalState;
exports.getAppOnCompleteAction = getAppOnCompleteAction;
exports.getBoxReference = getBoxReference;
exports.updateApp = updateApp;
//# sourceMappingURL=app.js.map
