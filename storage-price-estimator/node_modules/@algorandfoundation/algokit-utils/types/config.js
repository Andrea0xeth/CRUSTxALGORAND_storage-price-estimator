'use strict';

var util = require('../util.js');
var types_logging = require('./logging.js');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

/** Updatable AlgoKit config */
class UpdatableConfig {
    get populateAppCallResources() {
        return this.config.populateAppCallResources;
    }
    get logger() {
        return this.config.logger;
    }
    get debug() {
        return this.config.debug;
    }
    get projectRoot() {
        return this.config.projectRoot;
    }
    get traceAll() {
        return this.config.traceAll;
    }
    get traceBufferSizeMb() {
        return this.config.traceBufferSizeMb;
    }
    get maxSearchDepth() {
        return this.config.maxSearchDepth;
    }
    /**
     * Returns the current logger, or the null logger if true is passed in to `returnNullLogger`
     * @param returnNullLogger Whether or not to return the null logger
     * @returns The requested logger
     */
    getLogger(returnNullLogger) {
        if (returnNullLogger) {
            return types_logging.nullLogger;
        }
        return this.logger;
    }
    /**
     * Temporarily run with debug set to true.
     * @param lambda A lambda expression with code to run with debug config set to true
     */
    withDebug(lambda) {
        const original = this.config.debug;
        try {
            this.config.debug = true;
            lambda();
        }
        finally {
            this.config.debug = original;
        }
    }
    constructor() {
        this.config = {
            logger: types_logging.consoleLogger,
            debug: false,
            projectRoot: null,
            traceAll: false,
            traceBufferSizeMb: 256,
            maxSearchDepth: 10,
            populateAppCallResources: false,
        };
        if (util.isNode()) {
            this.configureProjectRoot();
        }
    }
    /**
     * Configures the project root by searching for a specific file within a depth limit.
     * This is only supported in a Node environment.
     */
    async configureProjectRoot() {
        if (!util.isNode()) {
            throw new Error('`configureProjectRoot` can only be called in Node.js environment.');
        }
        const fs = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespaceDefault(require('fs')); });
        const path = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespaceDefault(require('path')); });
        const _dirname = __dirname;
        if (!_dirname) {
            return;
        }
        let currentPath = path.resolve(_dirname);
        for (let i = 0; i < this.config.maxSearchDepth; i++) {
            if (fs.existsSync(`${currentPath}/.algokit.toml`)) {
                this.config.projectRoot = currentPath;
                break;
            }
            currentPath = path.dirname(currentPath);
        }
    }
    /**
     * Update the AlgoKit configuration with your own configuration settings
     * @param newConfig Partial or complete config to replace
     */
    configure(newConfig) {
        this.config = { ...this.config, ...newConfig };
    }
}

exports.UpdatableConfig = UpdatableConfig;
//# sourceMappingURL=config.js.map
